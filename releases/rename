#!/usr/bin/ruby

require 'optparse'

class OptionFormatError < StandardError
	def initialize(mess = "invalid argument")
		super(mess)
	end
end


class ARGVParser
	@@ERROR_MESSAGE = {
		enough:  "Not enough arguments",
		many:    "Too many arguments",
  	onlyone: "can be specified rename-option is only one"
	}
	
	@@HELP_MESSAGE = {
		replace: "replace target to STR",
		erase:   "erase target",
		number:  "replace target to number"
	}

	def initialize(argv)
		@argv = argv
		@rename_option = {}
		@other_option  = []
		@directory     = ""
		@target        = ""
	end
	
	attr_reader :argv
	attr_reader :rename_option
	attr_reader :other_option
	attr_reader :directory
	attr_reader :target

	#can access instance-variable using [:hash]
	def [](symb)
		self.send(symb)
	end

	#This function returns a rename-option, and it's argument
	#argvからrename-optionが取り抜かれる
	#オプションの整合性判定はしない
	def parse_rename_option
		
		def @rename_option.set!(rename_mode, opt_arg)
			fail OptionFormatError, @@ERROR_MESSAGE[:onlyone] unless self.empty?
			
			self[:mode] = rename_mode
			self[:arg]  = opt_arg
		end

		parser = OptionParser.new(nil, 10)
		parser.banner = 'Usage: rename [directory] [target-string] [-ren]'
		parser.on('-r STR',   @@HELP_MESSAGE[:replace]){|opt| @rename_option.set!(:replace, opt) }
		parser.on('-e',       @@HELP_MESSAGE[:erase])  {      @rename_option.set!(:erase,    "") }
		parser.on('-n [NUM]', @@HELP_MESSAGE[:number]) {|opt| @rename_option.set!(:number,  opt) }

		#set!からもメッセージが上がってくる
		begin
			parser.parse!(@argv)
		rescue OptionFormatError => ex
			raise OptionFormatError, ex.message
		rescue OptionParser::MissingArgument => ex
			raise OptionFormatError, ex.message
		rescue OptionParser::InvalidOption=> ex
			raise OptionFormatError, ex.message
		end

		#特異メソッドを消す
		class << @rename_option; remove_method :set! end

		return @rename_option
	end

	#-y Yes/Noを尋ねないで実行
	#-b バックアップを取る?
	#-h ヘルプを処理する
	def parse_other_option
		# parser = OptionParser.new
		# parser.on('-y')
		# parser.on('-h', '--help')
	end

	#Filed, when argv has the rest
	def parse_dir_targ
		if @argv.size < 2
			fail OptionFormatError, @@ERROR_MESSAGE[:enough]
		elsif 2 < @argv.size
			raise OptionFormatError, @@ERROR_MESSAGE[:many]
		end

	  @directory, @target = @argv.slice!(0,2)
	end

	#全てのパースと例外処理をやってくれる
	def all_parse
		begin
			parse_rename_option
			parse_other_option
			parse_dir_targ
			return self
		rescue OptionFormatError  => ex
			warn "error: #{ex.message}"
			exit 1
		end
	end
end#Parser


class RenameRoutineError  < StandardError; end      #code bug
class RenameStandardError < RenameRoutineError; end #この例外を補足する

class TargetPathes

	#ブロックを渡すとそのままリネームが実行できる
	def initialize(dir_path, mode)
		fail RenameStandard, "#{dir_path} not exists" unless Dir.exists?(dir_path)

		@pathes = Dir.glob(File.join(dir_path, "*"))
		return if @pathes.empty?
	
		case mode
		when :all
		when :file
			@pathes.select!{ |elem| File.file?(elem) }
		when :dir
			@pathes.select!{ |elem| File.directory?(elem) }
		else
			raise RenameRoutineError, "#{mode} is invalid mode, can use :all, :file, :dir"
		end

		#そのままリネーム
		return unless block_given?
		self.rename {|name| yield name }
	end

	#ブロック変数としてファイル名|ディレクトリ名を渡す
	#ブロック内でファイル名|ディレクトリ名を変更して関数に戻す
	def rename(&block)
		@pathes.each do |path|
			newname = block.call(File.basename(path))
			newpath = File.join(File.dirname(path), newname)
			File.rename(path, newpath);	
		end
	end

	def each(&block)
		@pathes.each {|path| block.call(File.basename(path)) }
	end

	def size
		@pathes.size
	end

end

class String
	def integer
		return Integer(self.sub(/^0*(.)/, '\1'))
	rescue 
		raise OptionFormatError, %Q["#{self}" can't convert to Integer]
	end
end

class Countup
	def initialize(opt_arg, path_num)
		opt_arg = "0" if opt_arg.nil?
		@count  = opt_arg.integer
		@digit  = opt_arg.size
		
		@digit  = Math.log10(path_num+@count).ceil if max-@count < path_num
	end

	def max
		10**@digit-1
	end

	def str
		fail RenameRoutineError, "count over the digit" if max < @count
		@count += 1
		return sprintf("%0#{@digit}d", @count-1)
	end
end

class NewWord
	def initialize(rename_opt, path_num)
		case rename_opt[:mode]
		when :replace, :erase
			@word_generator = lambda{ rename_opt[:arg] }
		when :number
			@count = Countup.new(rename_opt[:arg], path_num)
			@word_generator = lambda{ @count.str }
		else
			fail OptionFormatError, "#{rename_opt} isn't mode"
		end
	end

	def get
		@word_generator.call
	end
end


def simple_replace_aste!(filename, target, after_str)
	fail RenameRoutineError,'"*" not found' unless target.count("*") == 1

	pivod = target.delete("*")

	if target[0] == "*"
		filename.gsub!(/.*?(#{pivod})/, after_str + '\1')
	elsif target[-1] == "*"
		pivod.sub!(/^\^/, "$") #先頭が^なら$に置き換える
		pivod.gsub!("\\.", ".\\")

		filename.reverse!
		filename.gsub!(/.*?(#{pivod.reverse})/, after_str.reverse + '\1')
		filename.reverse!
	else #between
		front, back = target.split("*")

		#$のみが使用されていた場合は反転して処理
		if front[0] != "^" && back[-1] == "$" 
			back[-1] = "^" #下準備
			front.gsub!("\\.", ".\\")
			back.gsub!("\\.", ".\\")

			front, back = back.reverse, front.reverse

			filename.reverse!
			filename.gsub!(/(#{front}).*?(#{back})/, '\1' + after_str.reverse + '\2')
			filename.reverse!
		else#通常のbetween処理
			filename.gsub!(/(#{front}).*?(#{back})/, '\1' + after_str + '\2')
		end
	end

	return filename
end

#filenameは改変される、戻り値も改変後の値を返す
def simple_replace!(filename, target, after_str)
	target.gsub!(".", "\\.")
	target.gsub!("?", ".")

	case target.count("*")
	when 0
		filename.gsub!(/#{target}/, after_str)
	when 1
		simple_replace_aste!(filename, target, after_str)
	else
	 fail RenameStandardError, 'target can use "*" is only one'
	end

	return filename
end

#easy: non-break
def simple_replace(filename, target, after_str)
	simple_replace!(filename.dup, target.dup, after_str.dup)
end

class Renamer < ARGVParser
	def initialize(argv)
		super(argv)
	end

	def parse
		self.all_parse
		p self.rename_option

		@pathes  = TargetPathes.new(self.directory, :file)
		@newword = NewWord.new(self.rename_option, @pathes.size)
	end

	def rename
		newnames = []
		@pathes.each do |name|
			newname = simple_replace(name, self.target, @newword.get)
			puts "#{name}  =>  #{newname}"
			newnames.push(newname)
		end

		puts "Rename these? (y/N)"
		case STDIN.gets.chomp
		when "Y", "y", "YES", "yes"
			@pathes.rename do |name|
				newnames.shift
			end
		end
	end
end

r = Renamer.new(ARGV)
r.parse
r.rename
