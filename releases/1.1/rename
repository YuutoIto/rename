#!/usr/bin/ruby
require 'optparse'

class OptionFormatError < StandardError
	def initialize(mess = "invalid argument")
		super(mess)
	end
end


class ARGVParser
	@@ERROR_MESSAGE = {
		enough:  "Not enough arguments",
		many:    "Too many arguments",
  	onlyone: "can be specified rename-option is only one"
	}
	
	@@HELP_MESSAGE = {
		replace: "replace target-string to STR",
		erase:   "erase target-string",
		number:  "replace target-string to countup number"
	}

	def initialize(argv)
		@argv = (argv.empty?)? ["-h"]: argv
		@rename_option = Hash.new
		@other_option  = Array.new
		@directory     = String.new
		@target        = String.new
	end
	
	attr_reader :argv
	attr_reader :rename_option
	attr_reader :other_option
	attr_reader :directory
	attr_reader :target

	def debug_variable
		puts "argv #{@argv}"
		puts "rename_option #{@rename_option}"
		puts "other_option  #{@other_option}"
		puts "directory #{@directory}"
		puts "target #{@target}"
	end

	#can access instance-variable using [:hash]
	def [](symb)
		self.send(symb)
	end

	#This function returns a rename-option, and it's argument
	#オプションの整合性判定はしない
	def parse_rename_option
		
		def @rename_option.set!(rename_mode, opt_arg)
			fail OptionFormatError, @@ERROR_MESSAGE[:onlyone] unless self.empty?
			
			self[:mode] = rename_mode
			self[:arg]  = opt_arg
		end

		parser = OptionParser.new(nil, 10)
		parser.banner = 'Usage: rename [directory] [target-string] [-ren]'
		parser.on('-r STR',   @@HELP_MESSAGE[:replace]){|opt| @rename_option.set!(:replace, opt) }
		parser.on('-e',       @@HELP_MESSAGE[:erase])  {      @rename_option.set!(:erase,    "") }
		parser.on('-n [NUM]', @@HELP_MESSAGE[:number]) {|opt| @rename_option.set!(:number,  opt) }

		#set!からもメッセージが上がってくる
		begin
			parser.parse!(@argv)
		rescue OptionFormatError => ex
			raise OptionFormatError, ex.message
		rescue OptionParser::MissingArgument => ex
			raise OptionFormatError, ex.message
		rescue OptionParser::InvalidOption=> ex
			raise OptionFormatError, ex.message
		end

		#特異メソッドを消す
		class << @rename_option; remove_method :set! end

		return @rename_option
	end

	def parse_dir_targ
		if @argv.size <= 1
			fail OptionFormatError, @@ERROR_MESSAGE[:enough]
		elsif 3 <= @argv.size
			raise OptionFormatError, @@ERROR_MESSAGE[:many]
		end

	  @directory, @target = @argv#.slice!(0,2)
	end

	#全てのパースと例外処理をやってくれる
	def all_parse
		begin
			parse_rename_option
			parse_dir_targ
			return self
		rescue OptionFormatError  => ex
			warn "error: #{ex.message}"
			exit 1
		end
	end
end#Parser

class RenameRoutineError  < StandardError; end      #code bug
class RenameStandardError < RenameRoutineError; end #この例外を補足する

class String
	def integer
		return Integer(self.sub(/^0*(.)/, '\1'))
	rescue 
		raise OptionFormatError, %Q["#{self}" can't convert to Integer]
	end

	def join(path)
		File.join(self, path)
	end
end

class TargetPathes
	def initialize(dir_path, mode)
		fail RenameStandard, "#{dir_path} not exists" unless Dir.exists?(dir_path)

		@names = Dir.glob(dir_path.join("*"))
		return if @names.empty?
	
		case mode
		when :all
		when :file
			@names.reject!{ |name| !File.file?(name) }
		when :dir
			@names.reject!{ |name| !File.directory?(name) }
		else
			raise RenameRoutineError, "#{mode} is invalid mode, can use :all, :file, :dir"
		end
		
		@names.map!{ |name| File.basename(name) }
		@names.sort!
		@DIR_NAME = dir_path
	end

	def each(&block)
		@names.each{ |oldname| block.call(oldname) }
	end

	def size
		@names.size
	end
	
	def apply_name_pair
		recursive_rename(@path_set)
	end

	def set_name_pair(&block)
		@path_set = []
		@names.each do |oldname|
			newname = block.call(oldname)
			@path_set.push([@DIR_NAME.join(oldname), @DIR_NAME.join(newname)])
		end
		return nil
	end

	def safe_rename(path_pairs)
		overlap = []
		path_pairs.each do |oldpath, newpath|
			if (!File.exists?(newpath))
				File.rename(oldpath, newpath)
			elsif (oldpath != newpath)
				overlap.push([oldpath, newpath])
			end
		end

		return overlap
	end

	def recursive_rename(path_pair)
		count   = path_pair.size
		overlap = self.safe_rename(path_pair) #renameして重複を得る

		if (overlap.size == 0)
			return true
		elsif (overlap.size <  count) #重複が減っていれば
			return self.recursive_rename(overlap)
		elsif (overlap.size == count)	#重複が一つも解決しなければ
			warn "Overlap: The following files did not rename, because already exists"
			overlap.each {|old, new| puts "#{old} => #{new}" }
			return false
		end
	end
end

class Countup
	def initialize(opt_arg, path_num)
		opt_arg = "0" if opt_arg.nil?
		@count  = opt_arg.integer
		@digit  = opt_arg.size
		@digit  = Math.log10(path_num+@count).ceil if max-@count < path_num
		alias :call :str
	end

	def max
		10**@digit-1
	end

	def str
		fail RenameRoutineError, "count over the digit" if max < @count
		@count += 1
		return sprintf("%0#{@digit}d", @count-1)
	end
end

class NewWord
	def initialize(rename_opt, path_num)
		case rename_opt[:mode]
		when :replace, :erase
			@word_generator = lambda{ rename_opt[:arg] }
		when :number
			@word_generator = Countup.new(rename_opt[:arg], path_num)
		else
			fail OptionFormatError, "#{rename_opt} isn't mode"
		end
	end

	def str
		@word_generator.call
	end
end

def simple_replace_aste!(filename, target, after_str)
	fail RenameRoutineError,'"*" not found' unless target.count("*") == 1

	pivod = target.delete("*")

	if target[0] == "*"
		filename.gsub!(/.*?(#{pivod})/, after_str + '\1')
	elsif target[-1] == "*"
		pivod.sub!(/^\^/, "$") #先頭が^なら$に置き換える
		pivod.gsub!("\\.", ".\\")

		filename.reverse!
		filename.gsub!(/.*?(#{pivod.reverse})/, after_str.reverse + '\1')
		filename.reverse!
	else #between
		front, back = target.split("*")

		#$のみが使用されていた場合は反転して処理
		if front[0] != "^" && back[-1] == "$" 
			back[-1] = "^" #下準備
			front.gsub!("\\.", ".\\")
			back.gsub!("\\.", ".\\")

			front, back = back.reverse, front.reverse

			filename.reverse!
			filename.gsub!(/(#{front}).*?(#{back})/, '\1' + after_str.reverse + '\2')
			filename.reverse!
		else#通常のbetween処理
			filename.gsub!(/(#{front}).*?(#{back})/, '\1' + after_str + '\2')
		end
	end

	return filename
end

#filenameは改変される、戻り値も改変後の値を返す
def simple_replace!(filename, target, after_str)
	target.gsub!(".", "\\.")
	target.gsub!("?", ".")

	case target.count("*")
	when 0
		filename.gsub!(/#{target}/, after_str)
	when 1
		simple_replace_aste!(filename, target, after_str)
	else
	 fail RenameStandardError, 'target can use "*" is only one'
	end

	return filename
end

#easy non-break
def simple_replace(filename, target, after_str)
	simple_replace!(filename.dup, target.dup, after_str.dup)
end


class Renamer < ARGVParser
	def initialize(argv)
		super(argv)
	end

	def parse
		self.all_parse
		@pathes  = TargetPathes.new(self.directory, :file)
		@newword = NewWord.new(self.rename_option, @pathes.size)
	end

	def rename
		@pathes.set_name_pair do |oldname|
			newname = simple_replace(oldname, self.target, @newword.str)
			puts "#{oldname}  =>  #{newname}"
			next newname
		end

		puts "Rename these? (y/N)"
		case STDIN.gets.chomp
		when /Y/i, /YES/i
			@pathes.apply_name_pair
		end
	end

end

r = Renamer.new(ARGV)
r.parse
r.rename
