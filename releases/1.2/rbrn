#!/usr/bin/env ruby

#OptionParser::InvalidOptionを継承させたほうがいいかも
class OptionFormatError < StandardError
	def initialize(mess = "invalid argument")
		super(mess)
	end
end

class RenameRoutineError  < StandardError; end      #code bug
class RenameStandardError < RenameRoutineError; end #この例外を補足する



require 'optparse'

class ARGVParser
	@@ERROR_MESSAGE = {
		enough:  "Not enough arguments",
		many:    "Too many arguments",
  	onlyone: "can be specified rename-option is only one"
	}
	
	@@HELP_MESSAGE = {
		replace: "replace target-string to STR",
		erase:   "erase target-string",
		number:  "replace target-string to countup number"
	}

	attr_reader :argv
	attr_reader :rename_option
	attr_reader :other_option
	attr_reader :directory
	attr_reader :target

	def initialize(argv)
		@argv = (argv.empty?)? ["-h"]: argv
		@rename_option = Hash.new
		@other_option  = Array.new
		@directory     = String.new
		@target        = String.new
	end

	def debug_variable
		puts "argv #{@argv}"
		puts "rename_option #{@rename_option}"
		puts "other_option  #{@other_option}"
		puts "directory #{@directory}"
		puts "target #{@target}"
	end

	#can access instance-variable using [:hash]
	def [](symb)
		self.send(symb)
	end

	#-f Yes/Noを尋ねないで実行
	#-b バックアップを取る?
	#-s 出力フォーマット指定

	#This function returns a rename-option, and it's argument
	#オプションの整合性判定はしない
	def parse_rename_option
		def @rename_option.set!(rename_mode, opt_arg)
			fail OptionFormatError, @@ERROR_MESSAGE[:onlyone] unless self.empty?
			
			self[:mode] = rename_mode
			self[:arg]  = opt_arg
		end

		parser = OptionParser.new(nil, 10)
		parser.banner = 'Usage: rename [directory] [target-string] [-ren]'
		parser.on('-r STR',   @@HELP_MESSAGE[:replace]){|opt| @rename_option.set!(:replace, opt) }
		parser.on('-e',       @@HELP_MESSAGE[:erase])  {      @rename_option.set!(:erase,    "") }
		parser.on('-n [NUM]', @@HELP_MESSAGE[:number]) {|opt| @rename_option.set!(:number,  opt) }

		#set!からもメッセージが上がってくる
		begin
			parser.parse!(@argv)
		rescue OptionFormatError => ex
			raise OptionFormatError, ex.message
		rescue OptionParser::MissingArgument => ex
			raise OptionFormatError, ex.message
		rescue OptionParser::InvalidOption=> ex
			raise OptionFormatError, ex.message
		end

		#特異メソッドを消す
		class << @rename_option; remove_method :set! end

		return @rename_option
	end

	def parse_dir_targ
		if @argv.size <= 1
			fail OptionFormatError, @@ERROR_MESSAGE[:enough]
		elsif 3 <= @argv.size
			raise OptionFormatError, @@ERROR_MESSAGE[:many]
		end

		#要素を空にする必要がある
	  @directory, @target = @argv.slice!(0,2)
	end

	#全てのパースと例外処理をやってくれる
	def all_parse
		begin
			parse_rename_option
			parse_dir_targ
			return self
		rescue OptionFormatError  => ex
			warn "error: #{ex.message}"
			exit 1
		end
	end
end#Parser

=begin
ブロックを実行して新たな文字列を取得するようにはできたから
あとはgsub!にブロックを渡すだけだ

replase target. you can use regexp ^,$,?,*
メタ文字の効果が一般的なものとは一部違う

This program
 ^ matches the only front of string 先頭にある時のみメタ文字
 & matches the only back of string 末尾にある時のみメタ文字
 ? 内部で正規表現を使用するときに、任意の一文字に置き換わる
 * target中の* に0文字以上一致したfilenameの文字列を変更対象にする
=end


#simple_replace専用の関数
#エスケープしたくない文字もある
class String
	def simple_escape
		newstr = self.dup
		newstr.gsub!("(", "\\(")
		newstr.gsub!(")", "\\)")
		newstr.gsub!("[", "\\[")
		newstr.gsub!("]", "\\]")
		newstr.gsub!("{", "\\{")
		newstr.gsub!("}", "\\}")
		newstr.gsub!("+", "\\+")
		newstr.gsub!(".", "\\.")
		newstr.gsub!("?", ".")
		newstr.delete!('*')
		return newstr
	end

	def simple_escape!
		self.gsub!("(", "\\(")
		self.gsub!(")", "\\)")
		self.gsub!("[", "\\[")
		self.gsub!("]", "\\]")
		self.gsub!("{", "\\{")
		self.gsub!("}", "\\}")
		self.gsub!("+", "\\+")
		self.gsub!(".", "\\.")
		self.gsub!("?", ".")
		self.delete!('*')
	end
end

#filenameは改変される、戻り値も改変後の値を返す
def simple_replace!(filename, target, after_str)
	case target.count("*")
	when 0
		target.simple_escape! #ここでエスケープ
		filename.gsub!(/#{target}/, after_str.word)            #通常置き換え
	when 1
		simple_replace_aste!(filename, target, after_str) #*マッチ置き換え
	else
	 fail RenameStandardError, 'target can use "*" is only one'
	end

	return filename
end

def simple_replace(filename, target, after_str)
	simple_replace!(filename.dup, target.dup, after_str)
end

def simple_replace_aste!(filename, target, after_str)
	if target[0] == "*" || target[/^../] == "^*"
		target.simple_escape!
		filename.gsub!(/.*?(#{target})/, after_str.word + '\1')

	elsif target[-1] == "*" || target[/..$/] == "*$"
		target.sub!(/^\^/, "$") #先頭が^なら$に置き換える
		filename.reverse!
		target.simple_escape!  #reverse!したあとにespace

		filename.gsub!(/.*?(#{target.reverse})/, after_str.word.reverse + '\1')
		filename.reverse!

	else #between
		front, back = target.split("*")

		#if "$" other than unused, reverse strings
		if back[-1] == "$" && front[0] != "^" 
			back[-1] = "^"

			# 反転、エスケープして交換
			front.reverse!.simple_escape!
			back.reverse!.simple_escape!
			front, back = back, front

			filename.reverse!
			filename.gsub!(/(#{front}).*?(#{back})/, '\1' + after_str.word.reverse + '\2')
			filename.reverse!

		else#通常のbetween処理
			front.simple_escape!
			back.simple_escape!
			filename.gsub!(/(#{front}).*?(#{back})/, '\1' + after_str.word + '\2')
		end
	end

	return filename
end

#require './~test-simple-replace-aste'
#require './~test-simple-replace-non-aste'



class String
	def integer
		return Integer(self.sub(/^0*(.)/, '\1'))
	rescue 
		raise OptionFormatError, %Q["#{self}" can't convert to Integer]
	end

	def join(path)
		File.join(self, path)
	end
end

class TargetPathes
	def initialize(dir_path, mode)
		fail RenameStandard, "#{dir_path} not exists" unless Dir.exists?(dir_path)

		@names = Dir.glob(dir_path.join("*"))
		return if @names.empty?
	
		case mode
		when :all
		when :file
			@names.reject!{ |name| !File.file?(name) }
		when :dir
			@names.reject!{ |name| !File.directory?(name) }
		else
			raise RenameRoutineError, "#{mode} is invalid mode, can use :all, :file, :dir"
		end
		
		@names.map!{ |name| File.basename(name) }
		@names.sort!
		@DIR_NAME = dir_path
	end

	def each(&block)
		@names.each{ |oldname| block.call(oldname) }
	end

	def size
		@names.size
	end
	
	def apply_name_pair
		recursive_rename(@path_set)
	end

	def set_name_pair(&block)
		@path_set = []
		@names.each do |oldname|
			newname = block.call(oldname)
			@path_set.push([@DIR_NAME.join(oldname), @DIR_NAME.join(newname)])
		end
		return nil
	end

	def safe_rename(path_pairs)
		overlap = []
		path_pairs.each do |oldpath, newpath|
			if (!File.exists?(newpath))
				File.rename(oldpath, newpath)
			elsif (oldpath != newpath)
				overlap.push([oldpath, newpath])
			end
		end

		return overlap
	end

	def recursive_rename(path_pair)
		count   = path_pair.size
		overlap = self.safe_rename(path_pair) #renameして重複を得る

		if (overlap.size == 0)
			return true
		elsif (overlap.size <  count) #重複が減っていれば
			return self.recursive_rename(overlap)
		elsif (overlap.size == count)	#重複が一つも解決しなければ
			warn "Overlap: The following files did not rename, because already exists"
			overlap.each {|old, new| puts "#{old} => #{new}" }
			return false
		end
	end
end

class Countup
	def initialize(opt_arg, path_num)
		opt_arg = "0" if opt_arg.nil?
		@count  = opt_arg.integer
		@digit  = opt_arg.size
		@digit  = Math.log10(path_num+@count).ceil if max-@count < path_num
		alias :call :str
	end

	def max
		10**@digit-1
	end

	def str
		fail RenameRoutineError, "count over the digit" if max < @count
		@count += 1
		return sprintf("%0#{@digit}d", @count-1)
	end
end

class NewWord
	def initialize(rename_opt, path_num)
		case rename_opt[:mode]
		when :replace, :erase
			@word_generator = lambda{ rename_opt[:arg] }
		when :number
			@word_generator = Countup.new(rename_opt[:arg], path_num)
		else
			fail OptionFormatError, "#{rename_opt} isn't mode"
		end
	end

	def word
		@word_generator.call
	end
end







class Renamer < ARGVParser
	def initialize(argv)
		super(argv)
	end

	def parse
		self.all_parse
		@pathes  = TargetPathes.new(self.directory, :file)
		@newword = NewWord.new(self.rename_option, @pathes.size)
	end

	def rename
		@pathes.set_name_pair do |oldname|
			newname = simple_replace(oldname, self.target, @newword)
			newname = oldname if newname.empty?

			oldname = sprintf("%-32s", oldname) #インデントを揃える
			puts "#{oldname}  =>  #{newname}"
			next newname
		end

		puts "Rename these? (y/N)"
		case STDIN.gets.chomp
		when /Y/i, /YES/i
			@pathes.apply_name_pair
		end
	end
end

##renamer entry point
r = Renamer.new(ARGV)
r.parse
r.rename
